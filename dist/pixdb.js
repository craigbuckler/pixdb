/*
pixdb 1.0.0 - Promise-based indexedDB wrapper
https://github.com/craigbuckler/pixdb
Craig Buckler, 2023-08-18
*/
var a=class{#t=null;#r=null;#s=null;constructor(t,e,r){return this.#r=t||"db",this.#s=e||1,this.#i(r)}connect(){return this.#i().then(()=>!0).catch(()=>!1)}close(){this.#t.close(),this.#t=null}#i(t){return new Promise((e,r)=>{if(!("indexedDB"in window)){r(new Error("No indexedDB support"));return}let s=indexedDB.open(this.#r,this.#s);s.onsuccess=()=>{this.#t=s.result,e(this)},s.onerror=n=>{r(new Error(`IndexedDB error ${n.target.errorCode}: ${n.target.message}`,{cause:n}))},t&&(s.onupgradeneeded=n=>{t(s.result,n.oldVersion,n.newVersion)})})}get isConnected(){return!!this.#t}get name(){return this.#r}get version(){return this.#s}#u(t,e,r){return new Promise((s,n)=>{let{transaction:i,store:u}=this.#o(t,null,!0);i.oncomplete=()=>s(),i.onerror=o=>{n(new Error(o.target.error.message,{cause:o}))},e=Array.isArray(e)?e:[e],e.forEach(o=>{r?u.put(o):u.add(o)}),i.commit()})}add({store:t,item:e=[]}={}){return this.#u(t,e,!1)}put({store:t,item:e=[]}={}){return this.#u(t,e,!0)}#e(t,e,r,s){return new Promise((n,i)=>{s=Array.isArray(s)?s:[s];let u=r==="delete"||r==="clear",o=this.#o(t,e,u).store[r](...s);o.onsuccess=()=>n(o.result),o.onerror=()=>i(o.error??!1)})}count({store:t,index:e,lowerBound:r,upperBound:s}={}){return this.#e(t,e,"count",this.#n(r,s))}get({store:t,index:e,key:r}={}){return this.#e(t,e,"get",r)}getAll({store:t,index:e,lowerBound:r,upperBound:s,count:n}={}){return this.#e(t,e,"getAll",[this.#n(r,s),n])}getAllKeys({store:t,index:e,lowerBound:r,upperBound:s,count:n}={}){return this.#e(t,e,"getAllKeys",[this.#n(r,s),n])}delete({store:t,key:e}={}){return this.#e(t,null,"delete",e)}clear({store:t}={}){return this.#e(t,null,"clear")}getCursor({store:t,index:e,lowerBound:r,upperBound:s,direction:n="next",callback:i}={}){return new Promise((u,o)=>{let l=this.#o(t,e).store.openCursor(this.#n(r,s),n);l.onsuccess=()=>{let c=l.result;c?c.advance(i&&i(c)||1):u(!0)},l.onerror=()=>o(l.error)})}drop(){return new Promise((t,e)=>{this.close();let r=indexedDB.deleteDatabase(this.#r);r.onsuccess=()=>{this.#r=null,this.#s=null,t(!0)},r.onerror=()=>e(!1)})}#o(t,e,r){let s=this.#t.transaction(t,r?"readwrite":"readonly",{durability:r?"strict":"default"}),n=s.objectStore(t);return{transaction:s,store:e&&!r?n.index(e):n}}#n(t,e){let r;return t&&e?r=IDBKeyRange.bound(t,e):t?r=IDBKeyRange.lowerBound(t):e&&(r=IDBKeyRange.upperBound(e)),r}};export{a as PixDB};
